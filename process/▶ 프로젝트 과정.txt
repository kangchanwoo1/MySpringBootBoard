접속 URL : http://localhost:8080/board/list

▶ 개발환경 세팅 내역
※ 자바개발 키트(JDK)
 - OpenJDK 21 (버전: 21.0.9)
※ 통합 개발 환경 (IDE)
 - Eclipse IDE for Enterprise Java and Web Developers (이유 : Spring Tools (STS)가 내장되어 있어 Spring Boot 개발에 최적화됨)
※ 빌드도구
 - Apache Maven (버전: 3.9.11)
 -> 설정 : 시스템 환경 변수 M2_HOME에 Maven 설치 경로 지정 및 PATH 환경 변수에 %M2_HOME%\bin 추가.
※ 웹 프레임 워크
 - Spring Boot (버전: v3.2.0)
 -> 핵심 의존성 : spring-boot-starter-web, spring-boot-starter-thymeleaf, spring-boot-devtools, lombok, mysql-connector-j, spring-boot-starter-data-jpa
-> 설정 : pom.xml에서 spring-boot-starter-parent 버전 **3.2.0**으로 명확히 지정.
pom.xml의 maven-compiler-plugin 내 annotationProcessorPaths에 Lombok <version>1.18.30</version> 명시.
※  웹 서버
 - Apache Tomcat9.0.112 (Spring Boot와는 별개이며, JSP/Servlet 프로젝트를 이클립스에 연동할 때 사용) -> 스프링부트 프로젝트에는 미사용
 - Apache Tomcat/10.1.16 (Spring Boot에 기본적으로 내장되어 있으며, 8080 포트 사용.)
※ 데이터베이스 관련
 - MySQL -> 스키마(DB명): board_db
 - 데이터베이스 관리 도구: MySQL Workbench -> 스키마 생성 및 테이블 구조 확인 용도
 -> 사용순서
 1. board_db라는 데이터베이스 생성
 2. application.properties 설정 -> spring.datasource.url, username, password: MySQL 서버 연결 정보를 설정해서 애플리케이션이 DB에 접근할수있도록 추가
3. Board 엔티티 (Board.java) -> @Entity, @Table, @Id, @GeneratedValue, @Column 등의 JPA 어노테이션을 사용하여 각 필드가 데이터베이스의 컬럼(열)에 어떻게 매핑되는지를 명시
4. BoardRepository 인터페이스 -> JpaRepository<Board, Integer>를 상속받아서 기본적인 CRUD 메서드(findAll, findById, save, deleteById 등)들을 자동으로 사용할 수 있게 했어. SQL 쿼리 없이 메소드 호출만으로 DB 조작이 가능해졌음
5. Create(생성) : 게시글생성/저장
 - 목표: 새로운 게시글 데이터를 데이터베이스에 추가.
 - BoardService 메서드: boardService.write(Board board)
 - BoardRepository 메서드: boardRepository.save(board)
 -> 원리: Board 객체를 받아 createDate를 현재 시간으로 설정.
 -> boardRepository.save() 메서드를 호출하여 board 객체를 데이터베이스의 board 테이블에 새로운 레코드(행)로 삽입 (INSERT).
6. Read(읽기) : 게시글 조회
 - 목표1 : 데이터베이스에 있는 모든 게시글 목록을 불러옴.
 - BoardService 메서드: boardService.boardList()
 - BoardRepository 메서드: boardRepository.findAll()
 -> 원리 : boardRepository.findAll() 메서드를 호출하여 board 테이블의 모든 레코드를 List<Board> 형태로 조회 (SELECT * FROM board).
 - 목표2 : 특정 id를 가진 게시글의 상세 정보를 불러옴
 -> BoardService 메서드: boardService.getBoard(Integer id)
 -> BoardRepository 메서드: boardRepository.findById(id)
 -> 원리 : boardRepository.findById(id) 메서드를 호출하여 특정 id에 해당하는 레코드를 조회 (SELECT * FROM board WHERE id = ?).
 -> 결과를 Optional<Board>로 받아 게시글이 존재하면 반환하고, 없으면 null 처리.
7. Update(수정) : 게시글 수정
 - 목표 : 특정 id를 가진 게시글의 상세 정보를 불러옴.
 - BoardService 메서드: boardService.updateBoard(Board board)
 - BoardRepository 메서드: boardRepository.findById(id) 와 boardRepository.save(existingBoard) 조합.
 - 원리
 1. @Transactional 어노테이션으로 트랜잭션을 묶음
 2. 먼저 findById()로 기존 게시글(existingBoard)을 데이터베이스에서 불러옴
 3. 불러온 existingBoard 객체의 title, author, content, modifyDate 필드를 수정 요청으로 받은 새 값으로 업데이트.
 4. 변경된 existingBoard 객체를 boardRepository.save() 메서드에 다시 넘기면, id가 존재하기 때문에 JPA가 이를 감지하고 해당 레코드를 업데이트 (UPDATE)하는 SQL을 실행
8. Delete(삭제) : 게시글 삭제
 - 목표: 특정 id를 가진 게시글을 데이터베이스에서 제거.
 - BoardService 메서드: boardService.deleteBoard(Integer id)
 - BoardRepository 메서드: boardRepository.deleteById(id)
  - > 원리 : boardRepository.deleteById(id) 메서드를 호출하여 특정 id에 해당하는 레코드를 데이터베이스에서 삭제 (DELETE FROM board WHERE id = ?).

※ 백업 및 버젼관리 시스템 (git) 
 - git bash -> cd D:/SpringBootBoard/MySpringBootBoard/MySpringBootBoard (프로젝트의 최상위 폴더 이동 명령어)
  -> git bash를 사용할때 무조건 입력 해야함!
 - git init -> 초기화 되어있다면 -> Reinitialized existing Git repository in .../.git/ ( 로컬 저장소 초기화 명령어)
 - 이클립스에서 .gitignore 파일 생성 -> MySpringBootBoard 프로젝트의 최상위 폴더 -> new -> file
  -> 해당 코드에 관련 코드 작성 및 저장
 - git bash -> git add . (.gitignore 파일에 의해 무시되는 파일을 제외하고, 모든 프로젝트 파일들을 Git이 추적하고 관리할 준비 명령어, 별다른 오류가 없다면 성공)
 -  git bash -> git commit -m "Initial commit: Set up MySpringBootBoard project" (변경사항 로컬 저장소에 커밋 명령어) -> nothing to commit, working tree clean 메시지가 뜨면 이미 커밋이 완료된 상태
-  git bash -> git remote add origin https://github.com/kangchanwoo1/MySpringBootBoard.git -> error: remote origin already exists. 라고 뜨면 origin이라는 이름으로 원격 저장소 추가하려고 하는데, 그 이름은 이미 사용 중이라는 뜻
-  git bash -> git remote -v -> origin  https://github.com/kangchanwoo1/MySpringBootBoard.git (fetch)
                                          origin  https://github.com/kangchanwoo1/MySpringBootBoard.git (push) 라고 뜨면 로컬 Git 저장소가 kangchanwoo1/MySpringBootBoard.git GitHub 저장소와 origin이라는 이름으로 완벽하게 연결되어 있다는 뜻
-  git bash -> git push -u origin main -> MySpringBootBoard 프로젝트 코드들을 이 잘 연결된 GitHub 저장소로 업로드 (한번 성공적으로 인증되면 다시 id/pw를 묻는 자격증명 뜨지않음)
※ git 버전관리 관련
 - 이클립스 상에서 코드를 수정
 -  git bash -> git add . -> git에게 이 파일들을 커밋할준비가 되었다고 알려주는 명령어
 - git bash -> git commit -m "메시지(ex : 게시글 수정 기능 구현)" -> git은 내 로컬 컴퓨터에 버젼이 저장되었다고 기록하는 명령어
 - git bash -> git push origin main -> 로컬에 기록된 버전을 GitHub로 푸시해서 최종 백업하는 명령어
※ 만약 로컬 코드가 GitHub보다 뒤쳐져 있다면, git pull origin main을 먼저 하라는 에러가 뜰 수 있는데 그럴 땐 git pull origin main → git push origin main 순서로 하면 됨
※ https://github.com/kangchanwoo1/MySpringBootBoard -> 현재 프로젝트가 저장되어있는 git url
※ git status -> 변경사항 확인 명령어



▶ 톰캣서버 관련
※ 톰캣시작 시 에러 날 경우 (보통 예전 톰캣이 백그라운드에서 돌고있을수있음)
-> 해결방법(강제종료) : cmd -> netstat -ano | findstr :8080 -> PID번호 확인 -> taskkill /PID PID번호 /F

▶ pom.xml 관련
※ 헤드라인 오류 발생
-> 원인 : spring-boot-starter-parent 4.0.0 라인 -> 정식으로 릴리스되지 않은 버젼이기 때문
-> 해결방법 : 3.2.0으로 수정

▶ 404에러 관련
※ 스프링부트 run -> http://localhost:8080/ 조회시 404에러발생
-> 원인 : Spring Boot가 실제로 실행하는 데 필요한 컴파일된 HelloController.class 파일은 누락되어 있는 상태
-> class 파일이 없으니 Spring Boot는 컨트롤러의 존재조차 알 수 없었고, 그래서 어떤 웹 요청이 와도 처리해 줄 컨트롤러를 찾을 수 없어서 404에러 발생
※ 원인 진단 과정
1. 본 프로젝트 밖에서 PureJavaWebServer.java 파일을 만들어 실행 (Spring Boot나 Maven의 도움 없이 순수 자바 코드만으로 8080 포트에서 "Hello from Pure Java Web Server!" 페이지를 띄우는 간단한 프로그램) -> 접속성공 (DK, 8080 포트, 네트워크 통신은 완벽하게 작동
되는것으로 확인)
2.  404 에러의 원인은 시스템 환경이나 포트 문제가 아니라 오직 MySpringBootBoard 프로젝트의 "빌드 과정" 자체에 있다는 것을 확신!
3. CMD에서 mvn clean install 명령어를 쳐서 정확한 에러 메시지를 확인
4. 오류메시지 : [ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.11.0:compile (...) Resolution of annotationProcessorPath dependencies failed: version can neither be null, empty nor blank
-> pom.xml에 명시된 maven-compiler-plugin이 annotationProcessorPaths라는 설정 내부에서 lombok의 '버전' 정보를 찾지 못해 컴파일을 실패했다는 뜻
5. 수정사항 : pom.xml 파일의 <build> 섹션에서 maven-compiler-plugin 아래 annotationProcessorPaths 내부에 있는 lombok 의존성에 <version>1.18.30</version>을 명시적으로 추가
6. pom.xml 저장 및 이클립스 Maven 프로젝트 업데이트 후, 다시 mvn clean install을 실행
7. 해결완료 : 이번에는 BUILD SUCCESS 메시지가 뜨면서 HelloController.java를 비롯한 모든 소스 코드 파일들이 .class 파일로 성공적으로 컴파일되어 target/classes 폴더 안에 정상적으로 생성

▶ Maven 명령어 인식 불가관련('mvn'은(는) 내부 또는 외부 명령이 아닙니다.)
※ 문제발생 : CMD에서 mvn 명령어를 입력하자 "명령어를 인식할 수 없습니다" 에러 발생.
※ 원인 : Maven이 Windows 시스템의 PATH 환경 변수에 등록되어 있지 않았기 때문에 터미널에서 mvn 명령어를 찾지 못함.
※ 해결방법
1. Maven 공식사이트에서 Maven설치경로로 설정
2. 시스템 환경 변수 M2_HOME을 Maven 설치 경로로 설정.
3. 시스템 PATH 변수에 %M2_HOME%\bin을 추가.
4. CMD를 새로 열고 mvn -v를 통해 Maven 버전 정보가 정상 출력되는 것을 확인.

※  mvn clean install 실행 시 MissingProjectException (잘못된 디렉토리)
해결방법 : CMD -> cd /d -> 해당프로젝트 경로 조회확인 -> dir -> pom.xml이 정상적으로 존재하는 것을 확인.

※ mvn clean install 실행 결과 BUILD FAILURE 발생.
원인 : pom.xml의 <build> 섹션 내 maven-compiler-plugin 설정에서 annotationProcessorPaths에 포함된 lombok 의존성에 명시적인 <version> 정보가 누락되어 컴파일 플러그인이 해당 라이브러리를 찾지 못함.
해결방법 : pom.xml 내 maven-compiler-plugin 설정 중 lombok path에 <version>1.18.30</version> 추가.
-> 이클립스에서 Maven 프로젝트 업데이트 (Maven → Update Project...).
-> CMD -> mvn clean install 다시 실행.
-> BUILD SUCCESS

▶ 포트 관련 오류 (Port 8080 was already in use.)
원인 :  Spring Boot 내장 웹 서버(Tomcat)가 사용하려는 8080 포트를 이미 다른 프로그램이 점유하고 있음
해결방법 : CMD -> netstat -aon | findstr "8080" -> taskkill /F /PID PID번호 (이 당시에 2960)

▶ 데이터베이스 연동 관련
1. pom.xml파일에 MySQL JDBC 드라이버 의존성 추가

▶ 클래스 구문 오류발생 관련 1
※ 진행 : src/main/java/com.example.MySpringBootBoard.service 패키지에 BoardService.java 클래스를 생성. BoardRepository를 주입받아 getList() 메서드를 통해 모든 게시글 목록을 불러오는 비즈니스 로직을 구현.
1. 오류 발생 : private final BoardRepository boardRepository; 라인에서 The blank final field BoardRepository may not have been initialized 컴파일 에러 발생.
2. 원인 : BoardService 클래스에 @RequiredArgsConstructor 어노테이션이 있었음에도 불구하고, Eclipse IDE가 Lombok 플러그인을 제대로 인식하지 못해 final 필드 boardRepository를 초기화할 생성자를 찾지 못했기 때문. 
해결 : BoardService 클래스 내부에 public BoardService(BoardRepository boardRepository) { this.boardRepository = boardRepository; }와 같이 BoardRepository를 주입하는 생성자를 수동으로 직접 구현하여 에러 해결.

※ 진행 : 기존 HelloController.java 파일을 수정하여 게시글 목록을 처리하는 BoardController로 변경. BoardService를 주입받아 /board/list 경로 요청 시 boardService.getList()를 호출하고, 결과를 board_list.html 템플릿으로 전달하도록 구현.
1. 오류 발생 : public class BoardController { 라인에서 The public type BoardController must be defined in its own file 컴파일 에러 발생.
2. 원인: HelloController.java 파일 내에서 클래스 이름만 public class BoardController로 변경하고, 파일 이름은 HelloController.java로 그대로 두었기 때문. Java 컴파일러는 public 클래스 이름과 파일 이름이 정확히 일치해야 함을 요구함.
3. 해결 : 해결: Eclipse의 Refactor -> Rename... 기능을 사용하여 HelloController.java 파일 이름을 BoardController.java로 변경.

1. 오류 발생 : private final BoardService boardService; 라인에서 The blank final field BoardService may not have been initialized 컴파일 에러 발생.
2. 원인: BoardService와 동일하게 BoardController에도 @RequiredArgsConstructor 어노테이션이 붙어있었으나, Eclipse의 Lombok 플러그인 인식 문제로 인해 final 필드 boardService를 초기화할 생성자를 찾지 못했기 때문.
3. 해결: BoardController 클래스 내부에 public BoardController(BoardService boardService) { this.boardService = boardService; }와 같이 BoardService를 주입하는 생성자를 수동으로 직접 구현하여 에러 해결.

※ 진행 : src/main/resources/templates 폴더에 board_list.html 파일을 생성. Thymeleaf 문법을 사용하여 BoardController로부터 전달받을 boardList 데이터를 반복문(th:each)으로 출력하도록 구현. 부트스트랩 CSS CDN을 추가하여 기본 디자인 적용.
1. 오류 발생 : http://localhost:8080/board/list 접속 시 Whitelabel Error Page 발생. (이전 오류 해결 후 재발)
2. 원인: 로그 확인 결과, EL1008E: Property or field 'id' cannot be found on object of type 'com.example.MySpringBootBoard.entity.Board' - maybe not public or not valid? 에러가 출력됨. 이는 board_list.html에서 board.id, board.title 등에 접근하려 할 때, Board.java 엔티티 클래스에 Getter 메서드가 없다고 인식했기 때문. Board 클래스에 @Getter 어노테이션이 있었으나, BoardService, BoardController와 마찬가지로 Eclipse의 Lombok 플러그인 인식 문제로 getId(), getTitle() 등의 메서드가 Eclipse에서 생성되지 않은 것으로 간주된 것.
해결: Board.java 엔티티 클래스 내부에 getId(), getTitle(), getContent(), getAuthor(), getCreateDate(), getModifyDate() 등 모든 필드에 대한 Getter 및 Setter 메서드를 수동으로 직접 구현하여 에러 해결. 

▶ 클래스 구문 오류발생 관련 2
1. 오류 발생 : BoardService에서 findById() 관련 에러
-> 오류 메시지 : Optional cannot be resolved to a type / The method findById(Long) in the type CrudRepository<Board,Long> is not applicable for the arguments (Integer)
2. 원인 : java.util.Optional 클래스에 대한 import 문이 BoardService.java 파일에 누락되었기 때문.
3. 원인 : BoardRepository 인터페이스는 JpaRepository<Board, Integer>로 정의되어 Integer 타입의 ID를 처리해야 했음
4. 해결 과정 : java.util.Optional import 추가: BoardService.java 파일 상단에 import java.util.Optional; 구문을 추가하여 Optional cannot be resolved 에러 해결.
5. 해결과정 : BoardRepository.java 인터페이스에 Optional<Board> findById(Integer id) 라인에 @Override추가

▶ 프로젝트 동작구조 관련
※ 전체적인 흐름
1. URL 사용자 요청
-> http://localhost:8080/board/list -> 해당 주소로 GET요청을 보냄
2. Controller
-> 서블릿이 /board/list라는 GET 요청을 받으면, 이 요청을 처리할 적절한 @Controller를 찾기 시작
-> 웹 요청을 직접 받아 처리하고,  어떤 Service를 호출할지 결정. 데이터를 Model에 담아서 View에게 전달하는 역할
-> BoardService로부터 List<Board> 형태의 게시글 데이터를 받아와서, model.addAttribute("list", ...) 코드를 통해 이 데이터를 model에 "list"라는 이름으로 담음
-> return "board_list"; 코드를 통해 어떤 View (HTML 파일)를 사용자에게 보여줄지 DispatcherServlet에게 알려줌
3. Service
-> 실제 '비즈니스 로직'을 처리하는 핵심 계층
-> Controller로부터 받은 요청을 바탕으로 여러 Repository를 조합하거나 데이터 가공, 유효성 검사 등 순수한 핵심 로직을 담당
-> BoardController가 boardService.boardList()를 호출하면, BoardService의 boardList() 메서드가 실행
-> 이 메서드는 boardRepository.findAll()을 호출해서 BoardRepository에게 모든 게시글 데이터를 DB에서 가져오라고 요청
-> BoardRepository로부터 List<Board> 데이터를 받아 BoardController에게 다시 반환
4. Repository
->  데이터베이스에 직접 접근해서 데이터를 CRUD (생성, 조회, 수정, 삭제)하는 역할
-> BoardService가 boardRepository.findAll()을 호출하면, JPA가 이 호출을 가로채서 Board 엔티티의 정보를 바탕으로 실제 데이터베이스에 맞는 SQL 쿼리(예: SELECT * FROM board)를 생성
-> 생성된 SQL 쿼리를 MySQL 데이터베이스로 전송.
-> 데이터베이스로부터 조회된 결과(테이블 레코드)를 받아 Board 엔티티 객체로 변환해서 (Board 객체의 리스트로 만듦) BoardService에게 반환
5. Entity
-> 데이터베이스의 테이블과 1:1로 매핑되는 자바 객체(설계도). Board 엔티티는 board 테이블의 레코드(행) 하나를 표현
6. DB
-> board 테이블이 실제로 존재하고, 여기에 게시글 데이터들이 물리적으로 저장되어 있어. JPA가 요청한 SQL 쿼리를 처리하고 결과를 다시 JPA에게 전달
7. View (Thymeleaf HTML)
-> Controller가 return "board_list";와 같이 논리적인 뷰 이름만 넘겨주면, View Resolver가 이를 받아서 templates 폴더에서 board_list.html 파일을 찾아 View로 지정
-> Controller로부터 Model에 담겨 넘어온 데이터를 가지고 최종적으로 사용자에게 보여줄 HTML 페이지를 '렌더링'
-> board_list.html 파일은 Thymeleaf 문법(th:each, th:text 등)을 사용해서 Controller에서 Model에 담아준 "list" 데이터를 실제 게시글 제목과 내용으로 채워 넣고 동적으로 HTML을 생성

▶ 게시물에 첨부파일 업로드 할수있는 기능
1. 오류사항 : 게시글에 첨부된 파일을 클릭하면 Whitelabel Error Page 페이지 뜸
※ 해결방안
1. application.properties의 file.dir 경로를 애플리케이션이 인식할 수 있는 실제 폴더의 절대 경로로 명확하게 지정
2. 윈도우 탐색기에서 해당 경로에 uploads 폴더를 수동으로 생성
3. Spring Boot의 표준적인 파일 서빙 방법을 사용하기 위해 WebMvcConfigurer 인터페이스를 구현한 WebConfig.java 설정 클래스를 만들었어. 이 클래스에서 addResourceHandlers() 메서드를 오버라이드하여 /files/**라는 URL 요청을 실제 파일 저장 경로(file:///{절대경로}/uploads/)에 매핑
4. application.properties의 spring.web.resources.static-locations 설정은 더 이상 필요 없어져서 주석 처리













